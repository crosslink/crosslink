/*
 * EvaTablePanel.java
 *
 */

package org.inex.ltw.evaluationtool;

import java.awt.Color;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.awt.print.PrinterException;
import java.io.BufferedWriter;
import java.io.File;
import java.io.FileWriter;
import java.io.PrintWriter;
import java.sql.Connection;
import java.sql.DriverManager;
import java.sql.SQLException;
import java.sql.Statement;
import java.text.MessageFormat;
import java.text.SimpleDateFormat;
import java.util.Calendar;
import java.util.Vector;
import javax.swing.*;
import javax.swing.event.TableModelEvent;
import javax.swing.event.TableModelListener;
import javax.swing.table.DefaultTableModel;
import javax.swing.table.TableModel;
import javax.swing.table.TableRowSorter;

import org.inex.ltw.util.ltwColorEditor;
import org.inex.ltw.util.ltwColorRenderer;

/**
 * Created on 17 September 2007, 11:22
 * @author  Darren Huang
 */
public class EvaTablePanel extends JPanel {
    
    private TableRowSorter<DefaultTableModel> sorter;
    
    /** Creates new form EvaTablePanel */
    public EvaTablePanel() {
        initComponents();
        this.evaluateRunsToTable(new Object[][]{});
        
        this.evasTable.setDefaultRenderer(Color.class, new ltwColorRenderer(true));
        this.evasTable.setDefaultEditor(Color.class, new ltwColorEditor());
    }
    
    public EvaTablePanel(EvaTablePanel ecopy){
        initComponents();
        this.evasTable.setDefaultRenderer(Color.class, new ltwColorRenderer(true));
        this.evasTable.setDefaultEditor(Color.class, new ltwColorEditor());
        this.evasTable.setModel(ecopy.evasTable.getModel());
        this.sorter = new TableRowSorter<DefaultTableModel>((DefaultTableModel)this.evasTable.getModel());
        this.evasTable.setRowSorter(this.sorter);
        
    }
    
    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    // <editor-fold defaultstate="collapsed" desc=" Generated Code ">//GEN-BEGIN:initComponents
    private void initComponents() {
        etpPopupMenu = new javax.swing.JPopupMenu();
        etpMenuItemDelete = new javax.swing.JMenuItem();
        jScrollPane1 = new javax.swing.JScrollPane();
        evasTable = new javax.swing.JTable();
        this.evasTable.addMouseListener(new PopupListener());

        etpMenuItemDelete.setText("Delete");
        etpMenuItemDelete.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                etpMenuItemDeleteActionPerformed(evt);
            }
        });

        etpPopupMenu.add(etpMenuItemDelete);

        evasTable.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null},
                {null, null, null, null, null, null, null, null, null, null, null, null, null}
            },
            new String [] {
                "", "", "", "", "", "", "", "", "", "", "", "", "Title 13"
            }
        ) {
            boolean[] canEdit = new boolean [] {
                false, false, false, false, false, false, false, false, false, false, false, false, true
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        evasTable.setFillsViewportHeight(true);
        jScrollPane1.setViewportView(evasTable);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 400, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 300, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents
    
    private void etpMenuItemDeleteActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_etpMenuItemDeleteActionPerformed
        int[] selectedRows = this.evasTable.getSelectedRows();
        if (selectedRows.length!=0){
            javax.swing.table.DefaultTableModel theModel = (javax.swing.table.DefaultTableModel)this.evasTable.getModel();
            int reduceCount = 0;
            for (int i=0;i<selectedRows.length;i++) {
                theModel.removeRow(this.evasTable.convertRowIndexToModel(selectedRows[i]-reduceCount));
                reduceCount++;
            }
        }
    }//GEN-LAST:event_etpMenuItemDeleteActionPerformed
    
    boolean colorChange = false; 
    void evaluateRunsToTable(Object[][] evaData){
        final TableModel emodel = EvaTablePanel.createCustomEvaTableModel(evaData);
        emodel.addTableModelListener(
            // listen to Color value change
            new TableModelListener(){
                public void tableChanged(TableModelEvent e) {
                    if(e.getType()==TableModelEvent.UPDATE){
                        if(emodel.getColumnClass(e.getColumn()).equals(Color.class)){
                            if(colorChange==true) return;
                            colorChange = true;
                            Object color = emodel.getValueAt(e.getFirstRow(), e.getColumn());
                            Object runId = emodel.getValueAt(e.getFirstRow(), 0);
                            
                            for(int i=0;i<emodel.getRowCount();i++) {
                                Object otherId = emodel.getValueAt(i, 0);
                                if (otherId.equals(runId))
                                    emodel.setValueAt((Color)color, i, e.getColumn());
                            }
                            colorChange = false;
                        }
                    }
                }    
            }
        );
        this.evasTable.setModel(emodel);
        this.repaint();
    }
    
    Vector getModelData(){
        return ((DefaultTableModel)this.evasTable.getModel()).getDataVector();
    }
    
    void cleanAllEvaTable(){
        Object[][] emptyEvaData = {{"", "", "", "", "", "", "", "", "", "", "", "", ""}};
        this.evaluateRunsToTable(emptyEvaData);
    }
    
    void printEvaluationTable(){
        MessageFormat header = new MessageFormat("Page {0,number,integer}");
        try {
            this.evasTable.print(JTable.PrintMode.FIT_WIDTH, header, null);
        } catch (PrinterException ex) {
            ex.printStackTrace();
        }
    }
    
    void exportEvaTableToCSV() {
        try {
            String fileName = "EvaluationTable_" + this.getNow("MMddmmss") + ".CSV";
            File csvFile = new File(fileName);
            String[] columnTitle = new String[this.evasTable.getColumnCount()];
            for (int i=0; i<this.evasTable.getColumnCount(); i++) {
                columnTitle[i] = this.evasTable.getColumnModel().getColumn(i).getHeaderValue().toString();
            }
            String rowdata;
            BufferedWriter bw = new BufferedWriter(new FileWriter(csvFile, true));
            PrintWriter pw = new PrintWriter(bw);
            for (int j=0; j<this.evasTable.getColumnCount()-3; j++) {
                pw.print(columnTitle[j] + ",");
            }
            pw.println("");
            for (int k=0; k<this.evasTable.getRowCount(); k++) {
                for (int l=0; l<this.evasTable.getColumnCount()-3; l++) {
                    rowdata = this.evasTable.getValueAt(k, l).toString();
                    pw.print(rowdata + ",");
                }
                pw.println("");
            }
            pw.close();
            
        } catch (Exception E) {
            System.out.println("Error While Exporting Table "+E);
        }
    }
    
    private String getNow(String dateFormat) {
        Calendar cal = Calendar.getInstance();
        SimpleDateFormat sdf = new SimpleDateFormat(dateFormat);
        return sdf.format(cal.getTime());
    }
    
    void selectAllRunPlots() {
        TableModel tableData = this.evasTable.getModel();
        for (int i=0; i<tableData.getRowCount(); i++) {
            this.evasTable.setValueAt(Boolean.TRUE, i, 12);
        }
    }
    
    void unselectAllRunPlots() {
        TableModel tableData = this.evasTable.getModel();
        for (int i=0; i<tableData.getRowCount(); i++) {
            this.evasTable.setValueAt(Boolean.FALSE, i, 12);
        }
    }
    
    private final static DefaultTableModel createCustomEvaTableModel(Object[][] evaData){
        
        String[] columnNames = {"Run ID",
        "Type",
        "MAP",
        "R-Prec",
        "P5",
        "P10",
        "P20",
        "P30",
        "P50",
        "P250",
        "Color",
        "Thick",
        "Plot"
        };
        
        return new DefaultTableModel(evaData, columnNames){
            
            /*
             * JTable uses this method to determine the default renderer/
             * editor for each cell.  If we didn't implement this method,
             * then the last column would contain text ("true"/"false"),
             * rather than a check box.
             */
            public Class getColumnClass(int c) {
                return getValueAt(0, c).getClass();
            }
            
        };
        
    }
    
    void newFilter(String reg) {
        RowFilter<DefaultTableModel, Object> erf = null;
        //If current expression doesn't parse, don't update.
        try {
            String firstCol = this.evasTable.getColumnModel().getColumn(0).getHeaderValue().toString();
            if (firstCol.equalsIgnoreCase("Run ID")) {
                erf = RowFilter.regexFilter(reg, 0);
            } else if (firstCol.equalsIgnoreCase("Type")) {
                erf = RowFilter.regexFilter(reg, 1);
            } else {
                erf = RowFilter.regexFilter(reg, 0);
            } 
        } catch (java.util.regex.PatternSyntaxException e) {
            return;
        }
        sorter.setRowFilter(erf);
    }
    
    private final class PopupListener extends MouseAdapter {
        
        public void mousePressed(MouseEvent e) {
            maybeShowPopup(e);
        }
        
        public void mouseReleased(MouseEvent e) {
            maybeShowPopup(e);
        }
        
        private void maybeShowPopup(MouseEvent e) {
            if (e.isPopupTrigger()) {
                if(EvaTablePanel.this.evasTable.getSelectedRow()!=-1){
                    EvaTablePanel.this.etpPopupMenu.show(e.getComponent(),e.getX(), e.getY());
                }
            }
        }
    }
    
    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JMenuItem etpMenuItemDelete;
    private javax.swing.JPopupMenu etpPopupMenu;
    private javax.swing.JTable evasTable;
    private javax.swing.JScrollPane jScrollPane1;
    // End of variables declaration//GEN-END:variables
    
}
